import BathyConfig
import threading
import time
import traceback
import re

class TooManyThreadsException( Exception ):
    pass

# A class for creating, executing, synchronizing, and managing FunctionThreads.
# @param max = The max number of threads allowed to run simultaneously. Attempts to create additional threads when this limit has been reached will result in the raising of a TooManyThreadsException. The default value is 4
# @param output = The display module which this ThreadingManager will use to display the messages generated by it's threads
class ThreadingManager( object ):
    def __init__( self, max=4, output=None ):
        self.MaxAllowableThreads = max # The max number of threads allowed to be running simultaneously
        self.ThreadIDCounter = 0 # A variable used to ensure that no thread has the same ID as another
        self.ActiveThreads = list() # Initialize the list we'll use to store all currently active threads. Contains IDs, not the threads themselves
        self.ThreadCount = 0 # The number of active threads. Equal to len( ActiveThreads )
        self.AverageRunTime = -1 # The average runtime of the thread. -1 indicates that no threads have yet completed.
        self.TotalRunTime = 0 # The sum of all runtimes of all threads that have completed so far. Used to calculate average runtime
        self.NumCompletedThreads = 0 # Used to calculate the average runtime
        self.DisplayOutput = output # The module used to write messages to the display
        # Resource locks. Used to protect against memory and run-time errors. 
        self.CheckInLock = threading.RLock() # Only one thread may check in at a time
        self.CheckOutLock = threading.RLock() # Only one thread may check out at a time
        self.DisplayLock = threading.RLock() # Only one thread may print to the display at a time
        self.ExceptionLock = threading.RLock() # Only one thread may lose it's shit at a time

    def checkIn( self, FunctionThreadID ):
        self.ActiveThreads.append( FunctionThreadID )
        self.ThreadCount = len( self.ActiveThreads )

    # @param FunctionThread = The thread checking out
    # @param runTime = The runtime of the thread. Defaults to -1, which indicates that the thread did not complete successfully. An overriden value indicates successful completion, and represents the runtime of the thread.
    def checkOut( self, FunctionThreadID, runTime=-1 ):
        self.ActiveThreads.remove( FunctionThreadID )
        self.ThreadCount = len( self.ActiveThreads )
        if runTime > -1: # A value > -1 indicates a successful execution. Thus, we can update the average runtime value
            self.updateAverageRunTime( runTime )

    # Updates the AverageRunTime value for this ThreadingManager.
    # @param runTime = The runTime of the most recently completed thread.
    # NOTE: Should implement resource protection on the variables used
    def updateAverageRunTime( self, runTime ):
        self.TotalRunTime += runTime
        self.NumCompletedThreads += 1
        self.AverageRunTime = self.TotalRunTime / self.NumCompletedThreads

    # Used to create a new thread managed by this instance of ThreadingManager. Enforces the maximum number of threads allowed to be running simultaneously
    # @param function = The function the new thread will execute
    # @param args = The arguments that the passed function will require
    # @throws = This function raises a TooManyThreadsException if the max thread limit has already been reached.
    def CreateNewFunctionThread( self, function, args ):
        if self.ThreadCount >= self.MaxAllowableThreads:
			e = TooManyThreadsException()
			BathyConfig.ConditionalPrint( "Too many threads active" )
			raise e
        else:
            newThread = FunctionThread( self, self.ThreadIDCounter, function, args )
            newThread.start()
            self.ThreadIDCounter += 1

    def report( self ):
        print( "Registered thread IDs: %s" % ( self.ActiveThreads ) )

    def writeToOutput( self, message ):
        if self.DisplayOutput == None: # If this ThreadingManager has no output module for display, then it is not meant to output messages to any display
            pass
        else:
            self.DisplayOutput.Display( message ) # Otherwise, tell the Display module to display this message

    def handleException( self, e ):
		BathyConfig.ConditionalPrint( "An exception has been raised." ) # TODO: Intelligent exception handling
		raise e

    def isIdle( self ):
        if self.ThreadCount <= 0:
            return True
        else:
            return False

    def isBusy( self ):
        if self.ThreadCount > 0:
            return True
        else:
            return False

# A threadable object which accepts an arbitrary function and an array of arguments for said function.
# Upon starting, the thread executes the specified functions with the specified parameters.
# FunctionThread tracks it's own runtime, and reports it to it's ThreadingManager
# @param ThreadManager = The ThreadingManager
class FunctionThread( threading.Thread ):
    # @param ThreadManager = This thread's ThreadManager
    def __init__( self, ThreadingManager, ID, function, arguments ):
        threading.Thread.__init__( self, name=str( ID ) )
        self.ThreadingManager = ThreadingManager
        self.ID = ID
        self.function = function
        self.arguments = arguments
        self.ThreadingManager.CheckInLock.acquire()
        self.ThreadingManager.checkIn( self.ID ) # Check in with the thread manager
        self.ThreadingManager.CheckInLock.release()

    # Executes the function it was given upon initialization. Upon completing the function, the thread checks itself out with the threadmanager, and reports it's runtime
    def run( self ):
        self.startTime = time.time()
        try:
            self.function( *self.arguments )
        except Exception as e:
			raise e
			"""
            self.ThreadingManager.ExceptionLock.acquire()
            self.ThreadingManager.handleException( e )
            self.ThreadingManager.ExceptionLock.release()
			"""
        self.endTime = time.time()
        runTime = self.endTime - self.startTime
        self.ThreadingManager.CheckOutLock.acquire()
        self.ThreadingManager.checkOut( self.ID, runTime ) # Upon complete execution of it's assigned function, this thread checks itself out of the ThreadingManager, and then terminates
        self.ThreadingManager.CheckOutLock.release()

    # Method for writing outputs to the display
    def writeToOutput( self, message ):
        self.ThreadingManager.DisplayLock.acquire()
        self.ThreadingManager.writeToOutput( message )
        self.ThreadingManager.DisplayLock.release()
